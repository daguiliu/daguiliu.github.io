<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - 望尽天涯路</title>
  

  
  
  <meta name="description" content="">
  <meta name="author" content="David">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>


<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


 

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/favicon.png' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">望尽天涯路</a>
			</h1>
			<subtitle>
				
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/resume/">
						<span>Resume </span>
					</a>
				</div>
			</div>
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
				
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/resume/">
							<span>Resume</span>
						</a>
					</div>
			</div>
		
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/运维/">
						<span>运维</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/编程/">
						<span>编程</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
			<li><a href="/categories/运维/"><img src="/images/运维.svg" alt="运维" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='运维'></a></li>
		
			<li><a href="/categories/编程/"><img src="/images/编程.svg" alt="编程" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='编程'></a></li>
		
			<li><a href="/categories/生活/"><img src="/images/生活.svg" alt="生活" onerror='if(this.src != "/images/uncategorized.svg") this.src="/images/uncategorized.svg"' title='生活'></a></li>
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"Elasticsearch核心概念","date":"2018-08-25T09:29:12.000Z","content":"ES概述ElasticSearch,简称es。es是一个开源的高拓展的分布式全文检索引擎，它可以近乎实施的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用java开发并使用Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n谁在使用\n维基百科，类似百度百科，全文检索，高亮，搜索推荐\n国外新闻网站，类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据，数据分析…\nStack Overflow国外的程序异常讨论论坛 \nGitHub（开源代码管理），搜索上千亿行代码\n站内搜索，商业智能系统，电商网站\n日志数据分析，logstash采集日志，ES进行复杂的数据分析，ELK技术（elasticsearch+logstash+kibana）\n\n数据存储方式ElasticSearch是面向文档型的数据库，一条数据在这里就是一个文档。比如：12345678&#123;&quot;name&quot; :     &quot;John&quot;,&quot;sex&quot; :      &quot;Male&quot;,&quot;age&quot; :      25,&quot;birthDate&quot;: &quot;19900501&quot;,&quot;about&quot; :    &quot;I love to go rock climbing&quot;,&quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]&#125;\nElasticSearch是面向文档型的数据库，一条数据在这里就是一个文档。比如：\n\n\n\n关系型数据库\nElasticSerch\n\n\n\n\n数据库\n索引\n\n\n表\ntype\n\n\n行\ndocument\n\n\n列\nfield\n\n\n\nes中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档又包含多个字段（列）。\n倒排索引ES使用一种称为倒排索引的结构，它适用于快速的全文搜索。倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 lucene 的倒排索引，区别于传统的正向索引， 倒排索引会在存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。\n正排索引（传统）\n\n\n\nid\ncontent\n\n\n\n\n1000\nmy name is david\n\n\n1001\ndavid is boy\n\n\n\n倒排索引\n\n\n\nkeyword\nid\n\n\n\n\nmy\n1000\n\n\nname\n1000\n\n\nis\n1000,1001\n\n\ndavid\n1000,1001\n\n\nboy\n1001\n\n\n\nES架构\n一个运行中的Elasticsearch实例称为一个节点，而集群是由一个或者多个拥有相同cluster.name配置的节点组成，它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。当一个节点被选举成为主节点时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。\n分片Shards一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档数据的索引占据 1TB 的磁盘空间，任一节点都可能没有这样大的磁盘空间。或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，每一份就称之为分片。创建一个索引的时候，就可以指定想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。\n分片很重要，主要有两方面的原因：\n\n水平分割，提供系统容量\n分片后可以进行分布式的、并行的操作，进而提高性能吞吐量。副本Replicas在一个网络云的环境里，某个分片节点故障随时都可能发生。为了解决这个问题， Elasticsearch允许创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。\n\n复制分片之所以重要，有两个主要原因：\n\n在分片节点失败的情况下，提供了高可用性。因为这个原因，复制分片从不与原主分片置于同一节点上是非常重要的。\n扩展系统的搜索量吞吐量，因为搜索可以在所有的副本上并行运行。\n\n分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。\n路由计算当我们创建文档时，es如何决定这个文档应当被存储在分片1还是分片2中？是根据下面这个公式决定的：1shard = hash(routing) % number_of_primary_shards\nrouting 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数。\n分片控制我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求，每个节点都知道集群中任一文档位置。集群默认就会做负载均衡。\n\n数据写流程","tags":["es"],"path":"2018/08/25/Elasticsearch核心概念/","external_link":""},{"title":"","date":"2021-06-02T14:08:19.168Z","content":"开篇学习源码第一步就是搭建调试环境，但是看了网上大部分Elasticsearch调试方式都是配置各种环境变量然后直接启动Main方法，而且还各种报错。今天提供新的方式－－remote debug来避免这些麻烦。\n步骤环境首先要安装jdk8，gradle和Intellij IDEA\n源码下载拉取代码，checkout到想要调试的版本(这里切到v6.1.0，需要注意的是不同ES分支对gradle版本要求不一样，可以到README文件中查看对应到gradle版本要求)\n123git clone git@github.comelasticelasticsearchcd elasticsearchgit checkout v6.1.0\n导入到IDEA执行gradle idea,成功后会提示BUILD SUCCESSFUL，然后导入到IDEA\n123456789:test:fixtures:hdfs-fixture:idea:test:fixtures:krb5kdc-fixture:ideaModule:test:fixtures:krb5kdc-fixture:idea:test:fixtures:old-elasticsearch:ideaModule:test:fixtures:old-elasticsearch:ideaBUILD SUCCESSFULTotal time: 2 mins 2.159 secs\n使用gradle启动Elasticsearch1gradle run --debug-jvm\n执行成功后是这样的，其中8000就是远程debug端口\n\nimage.png\n配置remote debug点击IDEA的Edit Configurations，再点击➕\n\nimage.png\n填写主机和端口，Name是配置名称，可以自定义（我这里就填es），点OK保存配置\n\nimage.png\n 搜一下源码里面Elasticsearch类，，看到Main方法，先打个断点等会看效果\n\nimage.png\n 最后再点下绿色小虫子启动debug\n\nimage.png\n是不是在断点停下来了\n\nimage.png\n 跳过断点再看下控制台，是不是启动日志都出来了\n\nimage.png\n 再验证下是否启动成功\n\nimage.png\n原理一切源于被称作 Agent 的东西。JVM有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。 这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。 传递一个 Agent Lib 给 JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是 -agentlib:jdwp=… 来引入 jdwp 这个 Agent 的。 jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 jdwp.so 或者 jdwp.dll 支持实现的。简单来说， jdwp agent 会建立运行应用的 JVM 和调试者（本地或者远程）之间的桥梁。既然他是一个Agent Library, 它就有能力拦截运行的代码。 在 JVM 架构里， debugging 功能在 JVM 本身的内部是找不到的，它是一种抽象到外部工具的方式（也称作调试者 debugger）。这些调试工具或者运行在 JVM 的本地 或者在远程。这是一种解耦，模块化的架构。\n关于Agent还有很多值得研究的细节，甚至基于JVMTI自己实现。参考https:www.ibm.comdeveloperworkscnjavaj-lo-jpda2index.html\n","tags":[],"path":"2021/06/02/Elasticsearch源码-使用Intellij IDEA和remote debug调试源代码/","external_link":""},{"title":"Elasticsearch部署.md","date":"2021-05-19T17:13:39.000Z","content":"1、拉取镜像1docker pull elasticsearch:7.12.1\n2、创建并启动容器1docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; elasticsearch:7.12.1\n创建时，调整内存的分配“ES_JAVA_OPTS=-Xms512m -Xmx512m”，增加92009300的端口映射。\n3、检测是否可以正常访问\nhttp:192.168.1.162:9200\n4、找到es配置文件elasticsearch.yaml，配置跨域123docker exec -it es binbashcd configvi elasticsearch.yaml\n在文件末尾加上以下内容：12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;\n\n\ncluster.name：自定义集群名称；\nnetwork.host：当前es节点绑定的ip地址；\nhttp.cors.enabled：是否支持跨域，默认为false；\nhttp.cors.allow-origin：当设置允许跨域，默认为*，表示支持所有域名，如果我们只是允许某些网站能访问，那么可以使用正则表达式。\n\n5、安装es-head可视化插件12docker pull elasticsearch-head:5docker run -d -p 9100:9100 mobzelasticsearch-head:5\n访问地址：http:192.168.1.162:9100\n6、安装对应版本的kibana12docker pull kibana:7.12.1docker run -d -p 5601:5601 kibana:7.12.1\n访问地址：http:192.168.1.162:5601\n7、利用docker-compose部署es集群新建 docker-compose.yml123mkdir compose-testcd compose-testvi docker-compose.yml\n复制以下内容到docker-compose.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970version: &apos;2.2&apos;services:  es01:    image: docker.elastic.coelasticsearchelasticsearch:7.12.1    container_name: es01    environment:      - node.name=es01      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es02,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data01:usrshareelasticsearchdata    ports:      - 9200:9200    networks:      - elastic  es02:    image: docker.elastic.coelasticsearchelasticsearch:7.12.1    container_name: es02    environment:      - node.name=es02      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data02:usrshareelasticsearchdata    networks:      - elastic  es03:    image: docker.elastic.coelasticsearchelasticsearch:7.12.1    container_name: es03    environment:      - node.name=es03      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es02      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data03:usrshareelasticsearchdata    networks:      - elasticvolumes:  data01:    driver: local  data02:    driver: local  data03:    driver: localnetworks:  elastic:    driver: bridge\n启动集群1docker-compose up\n浏览器访问:http:192.168.1.162:9100\n参考: ES官网\n","tags":["es","linux","docker"],"path":"2021/05/20/Elasticsearch部署/","external_link":""},{"title":"java反射与代理模式","date":"2018-08-25T09:29:12.000Z","content":"java.lang.Object中getClass()方法的用途可以获取一个类的定义信息，然后使用反射去访问其全部信息(包括函数和字段)。还可以查找该类的ClassLoader，以便检查类文件所在位置等。例子：1Class class1=xxx.getClass();\nclass1带的方法有什么用？比如说可以返回类名，知道该类中字段，知道该类中方法名，知道该类中参数名，知道该类中方法返回类型等等。\njava中getClass()和.class的联系和区别一般情况下，getclass()方法和.class方法是等价的，都可以获得一个类型名。\n区别：两者最直接的区别就是，getClass()是一个类的实例所具备的方法，而.class方法是一个类的方法。另外getClass()是在运行时才确定的，而.class方法是在编译时就确定了。\n代理模式的特征与作用特征：代理类与委托类有同样的接口\n作用：代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。\n静态代理常规的代理模式有以下三个部分组成：\n功能接口123interface IFunction &#123;\tvoid doAThing();&#125;\n功能提供者12345class FunctionProvider implement IFunction &#123;\tpublic void doAThing &#123;\t\tSystem.out.print(do A);\t&#125;&#125;\n功能代理者1234567891011class Proxy implement IFunction &#123;\tprivate IFunction function;\tProxy(IFunction function) &#123;\t\tthis.function = function;\t&#125;\tpublic void doAThing &#123;\t      调用委托类方法前做一些操作\t\tfunction.doAThing();\t\t 调用委托类方法后也可以做一些操作\t&#125;&#125;\n静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。\n缺点：比如有多个接口需要进行代理，那么就要为每一个功能提供者创建对应的一个代理类，那就会越来越庞大。而且，所谓的“静态”代理，意味着必须提前知道被代理的委托类。\n动态代理动态代理类：在程序运行时，运用反射机制动态创建而成。\n动态代理的核心思想是通过 Java Proxy 类，为传入进来的任意对象动态生成一个代理对象，这个代理对象默认实现了原始对象的所有接口。\n123456interface IAFunc &#123;\tvoid doA();&#125;interface IBFunc &#123;\tvoid doB();&#125;\n12class A implement IAFunc &#123; ... &#125;class B implement IBFunc &#123; ... &#125;\n12345678910111213141516171819class TimeConsumeProxy implements InvocationHandler &#123;\tprivate Object realObject;\tpublic Object bind(Object realObject) &#123;\t\tthis.realObject = realObject;\t\tObject proxyObject = Proxy.newInstance(\t\t\trealObject.getClass().getClassLoader(),\t\t\trealObject.getClass().getInterfaces(),\t\t\tthis\t\t);\t\treturn proxyObject;\t&#125;\t@Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        long start = System.currentMillions();        Object result = method.invoke(target, args);        System.out.println(耗时： + (System.currentMillions() - start));        return result;    &#125;&#125;\n具体使用时：12345678public static void main(String[] args) &#123;\tA a = new A();\tIAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);\taProxy.doA();\tB b = new B();\tIBFunc bProxy = (IBFunc) new TimeConsumeProxy().bind(b);\tbProxy.doB();&#125;\n这里最大的区别就是：代理类和委托类互相透明独立，逻辑没有任何耦合，在运行时才绑定在一起。这也就是静态代理与动态代理最大的不同，带来的好处就是：无论委托类有多少个，代理类不受到任何影响，而且在编译时无需知道具体委托类。\n探索动态代理实现机制上面代码中最重要的就是:12345Object proxyObject = Proxy.newInstance(\t\t\trealObject.getClass().getClassLoader(),\t\t\trealObject.getClass().getInterfaces(),\t\t\tthis\t\t);\n通过 Proxy 工具，把真实委托类转换成了一个代理类，最开始提到了一个代理模式的三要素：功能接口、功能提供者、功能代理者；在这里对应的就是：realObject.getClass().getInterfaces()，realObject，TimeConsumeProxy。\n其实动态代理并不复杂，通过一个 Proxy 工具，为委托类的接口自动生成一个代理对象，后续的函数调用都通过这个代理对象进行发起，最终会执行到 InvocationHandler#invoke 方法，在这个方法里除了调用真实委托类对应的方法，还可以做一些其他自定义的逻辑，比如上面的运行耗时统计等。\n问题一: proxyObject 究竟是个什么 -&gt; 动态生成的 $Proxy0.class 文件在调用 Proxy.newInstance 后，Java 最终会为委托类 A 生成一个真实的 class 文件：$Proxy0.class，而 proxyObject 就是这个 class 的一个实例。\n在IDE反编译下$Proxy0.class文件1234567891011121314151617181920212223242526272829303132333435363738394041final class $Proxy0 extends Proxy implements IAFunc &#123;    private static Method m1;    private static Method m3;    private static Method m2;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);    &#125;    public final boolean equals(Object var1) throws  &#123;         省略    &#125;    public final void doA() throws  &#123;        try &#123;        \t 划重点            super.h.invoke(this, m3, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    public final String toString() throws  &#123;         省略    &#125;    public final int hashCode() throws  &#123;         省略    &#125;    static &#123;        try &#123;        \t 划重点            m3 = Class.forName(proxy.IAFunc).getMethod(doA, new Class[0]);            m1 = Class.forName(java.lang.Object).getMethod(equals, new Class[]&#123;Class.forName(java.lang.Object)&#125;);            m2 = Class.forName(java.lang.Object).getMethod(toString, new Class[0]);            m0 = Class.forName(java.lang.Object).getMethod(hashCode, new Class[0]);        &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());        &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());        &#125;    &#125;&#125;\n其中doA()里做的就是调用 TimeConsumeProxy#invoke() 方法。\n那么也就是说，下面这段代码执行流程如下：\n12IAFunc aProxy = (IAFunc) new TimeConsumeProxy().bind(a);aProxy.doA();\n基于传入的委托类 A，生成一个$Proxy0.class 文件；创建一个 $Proxy0.class 对象，转型为 IAFunc 接口；调用 aProxy.doA() 时，自动调用 TimeConsumeProxy 内部的 invoke 方法。\n问题二：proxyObject 是怎么一步步生成出来的 -&gt; $Proxy0.class 文件生成流程刚刚从末尾看了结果，现在我们回到代码的起始端来看：\n12345Object proxyObject = Proxy.newInstance(\t\t\trealObject.getClass().getClassLoader(),\t\t\trealObject.getClass().getInterfaces(),\t\t\tthis\t\t);\n先看Proxy.newInstance():\n1234567891011public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h) &#123;     复制要代理的接口\tfinal Class&lt;?&gt;[] intfs = interfaces.clone();\t 重点：生成 $Proxy0.class 文件并通过 ClassLoader 加载进来\tClass&lt;?&gt; cl = getProxyClass0(loader, intfs);\t 对 $Proxy0.class 生成一个实例，就是 `proxyObject`\tfinal Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);\treturn cons.newInstance(new Object[]&#123;h&#125;);&#125;\n再来看 getProxyClass0 的具体实现：ProxyClassFactory工厂类：\n1234567891011121314151617181920212223242526@Overridepublic Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;\t 参数为 ClassLoader 和要代理的接口\tMap&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);\t 1. 验证 ClassLoader 和接口有效性\tfor (Class&lt;?&gt; intf : interfaces) &#123;\t\t 验证 classLoader 正确性\t\tClass&lt;?&gt; interfaceClass = Class.forName(intf.getName(), false, loader);\t\tif (interfaceClass != intf) &#123;            throw new IllegalArgumentException(                intf +  is not visible from class loader);        &#125;\t\t 验证传入的接口 class 有效\t\tif (!interfaceClass.isInterface()) &#123; ... &#125;\t\t 验证接口是否重复\t\tif (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; ... &#125;\t&#125;\t 2. 创建包名及类名 $Proxy0.class\tproxyPkg = ReflectUtil.PROXY_PACKAGE + .;\tlong num = nextUniqueNumber.getAndIncrement();    String proxyName = proxyPkg + proxyClassNamePrefix + num;     3. 创建 class 字节码内容    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);     4. 基于字节码和类名，生成 Class&lt;?&gt; 对象    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);&#125;\n再看下第三步生成 class 内容 ProxyGenerator.generateProxyClass：12345678910111213 添加 hashCode equals toString 方法addProxyMethod(hashCodeMethod, Object.class);addProxyMethod(equalsMethod, Object.class);addProxyMethod(toStringMethod, Object.class); 添加委托类的接口实现for (int i = 0; i &lt; interfaces.length; i++) &#123;    Method[] methods = interfaces[i].getMethods();    for (int j = 0; j &lt; methods.length; j++) &#123;         addProxyMethod(methods[j], interfaces[i]);    &#125;&#125; 添加构造函数methods.add(this.generateConstructor());\n这里构造好了类的内容：添加必要的函数，实现接口，构造函数等，下面就是要写入上一步看到的 $Proxy0.class 了。1234567ByteArrayOutputStream bout = new ByteArrayOutputStream();DataOutputStream dout = new DataOutputStream(bout);dout.writeInt(0xCAFEBABE);...dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);...return bout.toByteArray();\n动态代理小结通过上面的讲解可以看出，动态代理可以随时为任意的委托类进行代理，并可以在 InvocationHandler#invoke 拿到运行时的信息，并可以做一些切面处理。\n在动态代理背后，其实是为一个委托类动态生成了一个 $Proxy0.class 的代理类，该代理类会实现委托类的接口，并把接口调用转发到 InvocationHandler#invoke 上，最终调用到真实委托类的对应方法。\n动态代理机制把委托类和代理类进行了隔离，提高了扩展性。\n参考: 文章\n","tags":["java","proxy","reflect"],"path":"2018/08/25/java反射与代理模式/","external_link":""},{"title":"springboot使用SpringRetry","date":"2018-08-06T16:00:00.000Z","content":"在分布式系统中，为了保证数据分布式事务的强一致性，大家在调用RPC接口或者发送MQ时，针对可能会出现网络抖动请求超时情况采取一下重试操作。大家用的最多的重试方式就是MQ了，但是如果你的项目中没有引入MQ，那就不方便了，本文主要介绍一下如何使用Spring Retry实现重试操作\n1、引入Spring Retry依赖12345678910&lt;dependency&gt;    &lt;groupId&gt;org.springframework.retry&lt;groupId&gt;    &lt;artifactId&gt;spring-retry&lt;artifactId&gt;    &lt;version&gt;1.1.4.RELEASE&lt;version&gt;&lt;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;artifactId&gt;    &lt;version&gt;1.8.9&lt;version&gt;&lt;dependency&gt;\n2、在启动入口加入重试配置1234567@SpringBootApplication@EnableRetrypublic class RetryApplication &#123;\tpublic static void main(String[] args) throws Exception&#123;\t\tSpringApplication.run(RetryApplication.class, args);\t&#125;&#125;\n3、编写测试service12345678910111213@Servicepublic class RetryService &#123;    @Retryable(value= &#123;RemoteAccessException.class&#125;,maxAttempts = 5,backoff = @Backoff(delay = 5000l,multiplier = 1))    public void retryTest(Integer id) throws Exception &#123;        System.out.println(do something...);        throw new RemoteAccessException(RemoteAccessException....);    &#125;    @Recover    public void recover(RemoteAccessException e,Integer id) &#123;        System.out.println(e.getMessage());        System.out.println(recover....);    &#125;&#125;\n其中，RemoteAccessException可以是自定义异常，\n@Retryable 标注此注解的方法在发生异常时会进行重试\n\nvalue：指定处理的异常类\nmaxAttempts：最大重试次数。默认3次\nbackoff： 重试等待策略。默认使用@Backoff注解\n\n@Backoff 重试等待策略\n\ndelay 重试等待的时间\nmultiplier 即指定延迟倍数，比如delay=5000l,multiplier=2,则第一次重试为5秒，第二次为10秒，第三次为20秒……\n\n@Recover 用于@Retryable重试失败后处理方法，此注解的方法参数和返回值一定要和@Retryable的一致，见上面代码。\n","tags":["springboot"],"path":"2018/08/07/springboot使用SpringRetry/","external_link":""},{"title":"springboot动态修改日志级别","date":"2018-08-21T16:00:00.000Z","content":"修改某个service的日志级别为DEBUG请求方式：post\n请求地址：服务器地址\n请求接口：loggerscom.service\n参数：{“configuredLevel”: “DEBUG”}\n","tags":["springboot"],"path":"2018/08/22/springboot动态修改日志级别/","external_link":""},{"title":"springboot服务shell启动脚本","date":"2018-08-28T02:13:39.000Z","content":"linux环境下，先新建xxxx.sh文件，下面是脚本内容1234567891011121314#!binshnetstat -anp | grep java | grep 1511|awk &#123;print $7&#125;|cut -d  -f 1|xargs kill -9netstat -anp | grep java | grep 1512|awk &#123;print $7&#125;|cut -d  -f 1|xargs kill -9rm -f tppidnohup  optAPPjavabinjava    -jar optAPPfeeder-1.0-SNAPSHOT.jar  --spring.config.location=classpath:application-test.yml  --server.port=1511 &gt; devnull 2&gt;&amp;1 &amp;nohup  optAPPjavabinjava    -jar optAPPfeeder-1.0-SNAPSHOT.jar  --spring.config.location=classpath:application-test-1.yml  --server.port=1512 &gt; devnull 2&gt;&amp;1 &amp;echo $! &gt; tppidecho Start Success!\n一、1&gt;devnull 2&gt;&amp;1 含义devnull ：代表空设备文件\n\n>  ：代表重定向到哪里，例如：echo “123” &gt; home123.txt\n1  ：表示stdout标准输出，系统默认值是1，所以”&gt;devnull”等同于”1&gt;devnull”\n2  ：表示stderr标准错误\n&amp;  ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1\n\n1 &gt; devnull 2&gt;&amp;1 语句含义：\n1 &gt; devnull ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。2&gt;&amp;1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。\n二、shell中$0,$?,$!等的特殊用法\n$$ Shell本身的PID（ProcessID）\n$! Shell最后运行的后台Process的PID\n$? 最后运行的命令的结束代码（返回值）\n$- 使用Set命令设定的Flag一览\n$ 所有参数列表。如”$“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。\n$@ 所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。\n$# 添加到Shell的参数个数\n$0 Shell本身的文件名\n\n三、netstat查询进程其中，netstat -anp | grep java | grep 1201|awk ‘{print $7}’|cut -d  -f 1|xargs kill -9查询java服务端口为1201的进程，并且杀死\n\nnetstat -anp 是查询所有后台进程，并且不反向解析域名。\ngrep java 全文匹配关键字java\ncut -d  -f 1是截取20294java并返回20194\nxargs是多行输入会以单行输出\n\n","tags":["linux","springboot","shell","netstat"],"path":"2018/08/28/springboot服务shell启动脚本/","external_link":""},{"title":"springcloud","date":"2018-08-16T16:00:00.000Z","content":"Spring Cloud是什么？Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。\n微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，springcloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，springcloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。\n主要的小弟有：Spring Cloud Config、Spring Cloud Netflix（Eureka、Hystrix、Zuul、Archaius…）、Spring Cloud Bus、Spring Cloud for Cloud Foundry、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Sleuth、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud Zookeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI。\n","tags":[],"path":"2018/08/17/springcloud(一)/","external_link":""},{"title":"如何搭建自己的博客网站","date":"2018-08-06T16:00:00.000Z","content":"本地搭建博客到git，参考: 文章\n搭建博客到自己的阿里云服务器，参考：文章1文章2\n以下是自己搭建博客网站的笔记：\n一、快速建一个博客网站Nexo是一种在本地编译成静态文件，上传到git的博客网站。\n1、git安装，此过程忽略\n2、Hexo安装12$ npm install hexo-cli -g$ npm install hexo-deployer-git --save\n3、Hexo初始化配置\na、先建一个目录，如：F:hexo\nb、进入该目录，右击”Git Bash Here”，执行命令：1$ hexo init\nc、执行下面两条命令，即可登录localhost:4000查看效果12$ hexo generate$ hexo server\n二、提交文章到博客网站1、如果本地电脑没有源码，看上面的2和3步骤。\n2、进入Hexo目录，打开_config.yml文件，找到deploy修改为自己的源码所在的git地址123deploy:  type: git  repo: git@github.com:daguiliudaguiliu.github.io.git\n3、打开项目的 Hexosource_posts ，新建一个后缀为.md的文件。\n4、接着执行命令：hexo d -g 即可完成文章的发布\n三、把git上面的Nexo项目部署到自己的阿里云服务器1、安装git和nginx先升级 CentOS 所有包，包括系统版本内核升级12yum -y updateyum install -y git nginx\n2、配置Nginx\n123mkdir datawwwhexochmod -R 777 datawwwhexovim etcnginxnginx.conf\n查找listen   80找到后，修改\n1root   datawwwhexo;\n3、配置Git Hooks初始化裸库123mkdir datablog.gitcd  datablog.gitgit init --bare\n4、配置Hooks脚本vim datablog.githookspost-receive添加以下脚本：1234#!binbashrm -rf datawwwbloggit clone datablog.git datawwwblog\n给post-receive脚本执行权限1chmod +x datablog.githookspost-receive\n5、部署Hexo博客到服务器，假如服务器ip为：152.92.13.78修改_config.yml123deploy:  type: git  repo: root@152.92.13.78:blog.git\n接着执行命令：1$ hexo d\n然后通过http:152.92.13.78即可访问博客。\n","tags":[],"path":"2018/08/07/如何搭建自己的博客网站/","external_link":""},{"title":"排查java的内存问题","date":"2018-08-16T16:00:00.000Z","content":"本文参考: 文章\n核心要点\n排查Java的内存问题可能会非常困难，但是正确的方法和适当的工具能够极大地简化这一过程\nJava HotSpot JVM会报告各种OutOfMemoryError信息，清晰地理解这些错误信息非常重要，在我们的工具箱中有各种诊断和排查问题的工具，它们能够帮助我们诊断并找到这些问题的根本原因；\n在本文中，我们会介绍各种诊断工具，在解决内存问题的时候，它们是非常有用的，包括：1234567891011121、HeapDumpOnOutOfMemoryError和PrintClassHistogram JVM选项2、Eclipse MAT3、Java VisualVM4、JConsole5、jhat6、YourKit7、jmap8、jcmd9、Java Flight Recorder和Java Mission Control10、GC Logs11、NMT12、原生内存泄露探测工具，比如dbx、libumem、valgrind和purify等。\n\n","tags":["java"],"path":"2018/08/17/排查Java的内存问题/","external_link":""},{"title":"随笔","date":"2018-08-21T16:00:00.000Z","content":"\n春风得意马蹄疾，一日看尽长安花。\n青春须早为，岂能长少年。\n\n","tags":["随笔"],"path":"2018/08/22/随笔/","external_link":""},{"title":"深入分析Volatile的实现原理","date":"2018-08-16T16:00:00.000Z","content":"本文参考: 文章\n引言Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。\nVolatile的官方定义Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。\n为什么要使用VolatileVolatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。\nVolatile的实现原理那么Volatile是如何来保证可见性的呢？在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。\n123456789Java代码：instance = new Singleton();instance是volatile变量汇编代码：0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);\n有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。\n\n将当前处理器缓存行的数据会写回到系统内存。\n这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。\n\n处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n","tags":["java"],"path":"2018/08/17/深入分析Volatile的实现原理/","external_link":""},{"title":"如何使用JMeter压力测试","date":"2018-08-06T16:00:00.000Z","content":"1、启动jmeter运行binjmeter.bat\n2、添加线程组在TestPlan节点上右键，Add–&gt;Threads(Users)–&gt;Thread Group。\n\nNumber of Threads (Users)：要模拟的并发用户量。\nRamp Up Period (in seconds)：在多长时间内均匀启动所有的线程。比如Number of Threads设为10，Ramp Up Period设为1，则jmeter每隔0.1秒启动1个线程。\nLoop Count：单用户任务重复执行的次数。可以设为Forever，这样jmeter就不会自动停止，需要强制终止。\n还可以设置Scheduler Configuration。这里有两组设置：指定StartTime和End Time让jmeter在特定的时间区段内执行工作；Startup Delay表示从当前时刻开始延迟多长时间开始运行，Duration设定运行时长。\n3、设置请求头HTTP Header manager在Thread Group上右击，Add–&gt;Config Element–&gt;HTTP Header manager\nMethod：请求方式 post或者get\npath：请求接口名\n4、设置请求默认值HTTP Request Defaults在Thread Group上右击，Add–&gt;Config Element–&gt;HTTP Request Defaults\nServer Name or IP：服务器地址\nport Number：端口\n5、用jmetr向服务器发送HTTP Request在Thread Group上右击，Add–&gt;Sampler–&gt;HTTP Request\n上面步骤4添加了请求值，这里就不需要填写服务器地址\nMethod：请求方式 post或者get\npath：请求接口名\n6、添加Listener在TestPlan上右击，Add–&gt;Listener–&gt;View Result Tree。可以查看请求结果。\n在TestPlan上右击，Add–&gt;Listener–&gt;Aggregate Report。可以查看jmeter生成的报告，Jmeter生成的报告有多种。\n","tags":["jmeter"],"path":"2018/08/07/如何使用JMeter压力测试/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/docker/" style="font-size: 0.8em; color: #488baf">docker</a> <a href="/tags/es/" style="font-size: 1.4em; color: #8f655d">es</a> <a href="/tags/java/" style="font-size: 2em; color: #d63e0a">java</a> <a href="/tags/jmeter/" style="font-size: 0.8em; color: #488baf">jmeter</a> <a href="/tags/linux/" style="font-size: 1.4em; color: #8f655d">linux</a> <a href="/tags/netstat/" style="font-size: 0.8em; color: #488baf">netstat</a> <a href="/tags/proxy/" style="font-size: 0.8em; color: #488baf">proxy</a> <a href="/tags/reflect/" style="font-size: 0.8em; color: #488baf">reflect</a> <a href="/tags/shell/" style="font-size: 0.8em; color: #488baf">shell</a> <a href="/tags/springboot/" style="font-size: 2em; color: #d63e0a">springboot</a> <a href="/tags/随笔/" style="font-size: 0.8em; color: #488baf">随笔</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
		
			
				
			
		
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
				
			
				
			
				
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/resume/">
							<span>Resume</span>
						</a>
					</div>
			</div>
		
		
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/运维/">
						<span>运维</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/编程/">
						<span>编程</span>
					</a>
				</div>
		</div>
		
		<div class='nav-more-item'>
				<div class="nav-name">
					<a class='nav-link' href="/categories/生活/">
						<span>生活</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: 'OWA6ER4W1Bs9uSbznd4IdXnf-gzGzoHsz',
        appKey: 'vjt17SYhxGl9L7oCD37DbXsi',
        placeholder: '',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'en'
    });
</script>








    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    <script type="text/javascript" src="https://l2.io/ip.js?var=user_ip"></script>
<script type='text/javascript'>
  
</script>


<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
